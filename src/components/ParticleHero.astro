---
/**
 * WebGL Particle Hero Component
 *
 * Interactive particle background using Three.js.
 * Particles react to mouse movement and scroll.
 *
 * USAGE:
 * <ParticleHero />
 */
---

<div class="particle-hero" id="particle-hero">
  <canvas id="particle-canvas"></canvas>
  <div class="particle-hero__content">
    <slot />
  </div>
</div>

<style>
  .particle-hero {
    position: relative;
    min-height: 100vh;
    width: 100%;
    overflow: hidden;
  }

  #particle-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  .particle-hero__content {
    position: relative;
    z-index: 1;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>

<script>
  import * as THREE from 'three';

  class ParticleSystem {
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private particles: THREE.Points;
    private particleCount: number = 2000;
    private mouseX: number = 0;
    private mouseY: number = 0;
    private targetMouseX: number = 0;
    private targetMouseY: number = 0;
    private scrollY: number = 0;
    private time: number = 0;
    private velocities: Float32Array;
    private originalPositions: Float32Array;
    private canvas: HTMLCanvasElement;
    private animationId: number = 0;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.scene = new THREE.Scene();

      // Camera setup
      this.camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      this.camera.position.z = 50;

      // Renderer setup
      this.renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
        antialias: true,
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Initialize particles
      this.velocities = new Float32Array(this.particleCount * 3);
      this.originalPositions = new Float32Array(this.particleCount * 3);
      this.particles = this.createParticles();
      this.scene.add(this.particles);

      // Event listeners
      this.bindEvents();

      // Start animation
      this.animate();
    }

    private createParticles(): THREE.Points {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(this.particleCount * 3);
      const colors = new Float32Array(this.particleCount * 3);
      const sizes = new Float32Array(this.particleCount);

      // Get theme colors from CSS
      const style = getComputedStyle(document.documentElement);
      const primaryColor = new THREE.Color(style.getPropertyValue('--color-accent-primary').trim() || '#6366f1');
      const secondaryColor = new THREE.Color(style.getPropertyValue('--color-accent-secondary').trim() || '#8b5cf6');
      const tertiaryColor = new THREE.Color(style.getPropertyValue('--color-accent-tertiary').trim() || '#ec4899');

      for (let i = 0; i < this.particleCount; i++) {
        const i3 = i * 3;

        // Distribute particles in a spherical pattern with some randomness
        const radius = 30 + Math.random() * 40;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i3 + 2] = (Math.random() - 0.5) * 60;

        // Store original positions
        this.originalPositions[i3] = positions[i3];
        this.originalPositions[i3 + 1] = positions[i3 + 1];
        this.originalPositions[i3 + 2] = positions[i3 + 2];

        // Random velocities for organic movement
        this.velocities[i3] = (Math.random() - 0.5) * 0.02;
        this.velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
        this.velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;

        // Color variation
        const colorChoice = Math.random();
        let color: THREE.Color;
        if (colorChoice < 0.4) {
          color = primaryColor;
        } else if (colorChoice < 0.7) {
          color = secondaryColor;
        } else {
          color = tertiaryColor;
        }

        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;

        // Variable sizes
        sizes[i] = Math.random() * 2 + 0.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      // Custom shader material for better particles
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float uTime;
          uniform float uPixelRatio;

          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * uPixelRatio * (50.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;

          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;

            float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
            gl_FragColor = vec4(vColor, alpha * 0.8);
          }
        `,
        transparent: true,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      return new THREE.Points(geometry, material);
    }

    private bindEvents(): void {
      window.addEventListener('resize', this.onResize.bind(this));
      window.addEventListener('mousemove', this.onMouseMove.bind(this));
      window.addEventListener('scroll', this.onScroll.bind(this));
    }

    private onResize(): void {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const material = this.particles.material as THREE.ShaderMaterial;
      material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
    }

    private onMouseMove(event: MouseEvent): void {
      this.targetMouseX = (event.clientX / window.innerWidth) * 2 - 1;
      this.targetMouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    private onScroll(): void {
      this.scrollY = window.scrollY;
    }

    private animate(): void {
      this.animationId = requestAnimationFrame(this.animate.bind(this));

      this.time += 0.01;

      // Smooth mouse following
      this.mouseX += (this.targetMouseX - this.mouseX) * 0.05;
      this.mouseY += (this.targetMouseY - this.mouseY) * 0.05;

      // Update particle positions
      const positions = this.particles.geometry.attributes.position.array as Float32Array;

      for (let i = 0; i < this.particleCount; i++) {
        const i3 = i * 3;

        // Organic floating motion
        positions[i3] = this.originalPositions[i3] +
          Math.sin(this.time + i * 0.1) * 2 +
          this.mouseX * 5;

        positions[i3 + 1] = this.originalPositions[i3 + 1] +
          Math.cos(this.time + i * 0.1) * 2 +
          this.mouseY * 5 -
          this.scrollY * 0.02;

        positions[i3 + 2] = this.originalPositions[i3 + 2] +
          Math.sin(this.time * 0.5 + i * 0.05) * 3;
      }

      this.particles.geometry.attributes.position.needsUpdate = true;

      // Rotate entire system slowly
      this.particles.rotation.y = this.time * 0.05 + this.mouseX * 0.2;
      this.particles.rotation.x = this.mouseY * 0.1;

      // Update shader uniforms
      const material = this.particles.material as THREE.ShaderMaterial;
      material.uniforms.uTime.value = this.time;

      this.renderer.render(this.scene, this.camera);
    }

    public destroy(): void {
      cancelAnimationFrame(this.animationId);
      window.removeEventListener('resize', this.onResize.bind(this));
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('scroll', this.onScroll.bind(this));
      this.particles.geometry.dispose();
      (this.particles.material as THREE.Material).dispose();
      this.renderer.dispose();
    }
  }

  // Initialize on DOM load
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
    if (canvas) {
      const particleSystem = new ParticleSystem(canvas);

      // Cleanup on page navigation
      document.addEventListener('astro:before-swap', () => {
        particleSystem.destroy();
      });
    }
  });
</script>
